>MyBatis下载地址：https://github.com/mybatis/mybatis-3
>
>笔记参照视频：B站尚硅谷Mybatis视频

# Mybatis

## 一、Mybatis简介

## MyBatis历史

MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github。

>在MyBatis3版本的jar包的包命名方式仍然是以iBatis命名
>
>下载Mybatis相关的jar包需要从Github下载，也可以通过Maven，从中央仓库或镜像网站来直接下载

iBatis一词来源于“internet”和“abatis”的组合，是一个**基于Java的持久层框架**。 iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO）。

* SQL Maps ：SQL映射，把java中的实体对象映射为数据库的一条记录，或者是把数据库的一条记录查询为java中的一个实体对象
* Data Access Objects（DAO）：即三层架构的DAO层，主要作用为数据访问对象，来进行数据访问，也就是Mybatis封装了JDBC，可以通过它来连接数据库和访问、操作数据库的数据

## MyBatis特性

* MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的**持久层框架**

  * 定制化SQL：即SQL语句由自己写，便于维护SQL语句
  * 存储过程:存储过程是指一组预先编译好的SQL语句的集合，类似于批处理语句，向外暴露一个名字，需要时通过名字进行调用。
  * 高级映射：当我们去查询一条数据时，如果字段名和属性名一致，那么可以自动的将数据转化为对应的实体类对象，但存在特殊情况：字段名和属性不一致、多对一的映射、一对多的映射，这个时候不能正常映射，Mybatis提供了解决方案即高级映射

* MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集

  * 避免了几乎所有的 JDBC 代码：JDBC代码过程几乎都差不多，即注册驱动、获取连接对象、获取预编译对象、执行SQL语句获得结果，为了简化将JDBC代码进行了封装
  * 避免手动设置参数：开发方向为BS系统，很多数据需要从浏览器传输给服务器，需要将其手动拼接到SQL语句，在JDBC中需要进行手动拼接或者占位符赋值方式，Mybatis提供了对应的两种方式，#大括号方式和$大括号方式，分别对应JDBC的两种方式
  * 避免获取结果集：在查询数据库后会获取一个结果集，对结果集需要进行解析来将数据库的记录转化为Java对象，Mybatis中不需要我们获取结果集和手动解析

* MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old JavaObjects，普通的Java对象）映射成数据库中的记录

  * Mybatis对数据库的操作有两种方式：XML和注解

* MyBatis 是一个 半自动的ORM（Object Relation Mapping 对象关系映射）框架

  * Object Relation Mapping（ORM） 对象关系映射：

    * 对象：Javav实体类对象 

    * 关系：关系型数据库

    * 映射：儿子之间的对应关系

    * ORM即把java对象和数据库中的记录创建映射关系

    * ORM是一种思想

      ![image-20220730224125115](../pic/image-20220730224125115.png)

  * 全自动：Hibernate，半自动：Mybatis，手动：JDBC



## 和其它持久化层技术对比

* JDBC:

  * SQL 夹杂在Java代码中耦合度高，导致硬编码内伤

    >java项目以后要打包为jar包，web工程打包成war包，硬编码即把SQL语句写死在Java代码中，java代码需要先编译，再执行，再打包，再对SQL语句的维护过程中可能需要修改SQL语句，那么需要修改源代码，需要重新编译、执行、打包

  * 维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见

  * 代码冗长，开发效率低

* Hibernate 和 JPA

  * 操作简便，开发效率高

  * 程序中的长难复杂 SQL 需要绕过框架

    >简单的SQL语句Hibernate可以实现，但长难SQL需要绕过框架自己实现，而Hibaernate对自己写的SQL语句执行非常麻烦，不推荐

  * 内部自动生产的 SQL，不容易做特殊优化

  * 基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难。

    >表跟实体类需要完全映射

  * 反射操作太多，导致数据库性能下降

* MyBatis

  * 轻量级，性能出色

  * SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据

    >Mybatis操作数据库有两种方式，XML和注解，教学主讲XML方式，此时SQL语句写在XML中，和Java代码分开，维护SQL只需要修改XML文件

  * 开发效率稍逊于HIbernate，但是完全能够接受

## 二、搭建MyBatis

>各个配置文件模板在mybatis包中的pdf文档Getting Started 章节中可以找到，然后根据实践情况修改

## 创建MyBatis的核心配置文件

* 习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring
  之后，这个配置文件可以省略，所以大家操作时可以直接复制、粘贴。

* 核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息

  >**核心配置文件配置如何连接数据库，映射文件配置如何操作数据库**

* 核心配置文件存放的位置是src/main/resources目录下

````xml
<?xml version="1.0" encoding="UTF-8" ?> 
<!--引入xml约束的dtd文件，gui'd-->
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"> 
<configuration> 
    <!--设置连接数据库的环境--> 
    <environments default="development"> 
        <environment id="development"> 
        <transactionManager type="JDBC"/> 
            <dataSource type="POOLED"> 
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3306/ssm? serverTimezone=UTC"/> 
                <property name="username" value="root"/> 
                <property name="password" value="root"/> 
            </dataSource> 
        </environment> 
    </environments> 
    <!--引入映射文件--> 
    <mappers> 
        <mapper resource="mappers/UserMapper.xml"></mapper>
    </mappers>
</configuration>
````

核心配置文件解析：

* 我们会通过读取核心配置文件来获取操作数据库的对象，然后就可以执行映射文件中的SQL语句，为了后面能找到SQL语句，需要将映射文件引入核心配置文件

## 创建mapper接口

* MyBatis中的mapper接口相当于以前的dao。但是区别在于，**mapper仅仅是接口，我们不需要提供实现类。Mybatis会为其创作代理实现类，当我们调用接口中的方法，会直接对应一条SQL语句并执行**

* 取名规则：操作的表名（驼峰命名）+Mapper

````java
public interface UserMapper { 
 
    int insertUser(); 
    int deleteUser();
    int updateUser();
    User selectUser();
}
````



## 创建MyBatis的映射文件



* Mapper接口对应了一个映射文件，Mapper接口中的一个方法对应映射文件的一个SQL语句，Mybatis会将Mapper接口中的方法关联到映射文件中的SQL语句

* MyBatis映射文件用于编写SQL，访问以及操作表中的数据

* 一个映射文件对应一个实体类，对应一张表的操作

* MyBatis映射文件存放的位置是src/main/resources/mappers目录下

* MyBatis中可以面向接口操作数据，为了保证Mapper和映射文件正确对应，要保证两个一致：

  * mapper接口的全类名和映射文件的命名空间（namespace）保持一致

  * mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致

    >namespace是映射文件的唯一标识，id是一个映射文件中方法的唯一标识，则两者一共为一个SQL语句的唯一标识
    >
    >这样Mybatis会根据Mapper接口的全类名找到映射文件，根据接口的方法名找到对应的SQL语句

* 映射文件的命名规则：表所对应的实体类的类名+Mapper.xml例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml

````xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.mapper.UserMapper">

    <!--int insertUser();-->
    <insert id="insertUser">
insert into t_user values(null,'admin','123456',23,'男','12345@qq.com')
    </insert>
    
    <!--  int deleteUser();-->
    <delete id="deleteUser">
        delete from t_user where id=1
    </delete>

    <!--int updateUser();-->
    <update id="updateUser">
        update t_user set username='zmt',password='123' where id=2
    </update>
    
     <!--int selectUser();-->
    <!--resultType：设置结果类型，即查询的数据要转换为的Java类型
        resultMap：自定义映射，处理一对多、多对一的映射关系、也适用于属性名和字段名不一致的情况-->
    <select id="selectUser" resultType="com.pojo.User">
        select * from t_user where id=2
    </select>
    
</mapper>
````





## 通过junit测试功能

* 步骤：

  1. 读取MyBatis的核心配置文件 

  2. 根据核心配置文件获取执行SQL语句的对象SqlSession

     >SqlSession：代表Java程序和数据库之间的会话。（HttpSession是Java程序和浏览器之间的会话）
     >
     >SqlSessionFactory：是“生产”SqlSession的“工厂”。
     >工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象。

  3. 获取Mapper接口的代理实现类对象

     >代理实现类重写了接口方法，过程即：这样Mybatis会根据Mapper接口的全类名找到映射文件，根据接口的方法名找到对应的SQL语句

  4. 执行Mapper接口中的方法

````java
           @Test
    public void testInsert() throws IOException {
            //获取字节输入流：读取MyBatis的核心配置文件
        InputStream is = Resources.getResourceAsStream("mybatis-config.xml");
           //创建SqlSessionFactoryBuilder对象
        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
            //通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象
        SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);
            //创建SqlSession对象，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务
            //即使用该语句SqlSession sqlSession = sqlSessionFactory.openSession();最后需要sqlSession.commit();
            //创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交
        SqlSession sqlSession = sqlSessionFactory.openSession(true);
            //通过代理模式创建UserMapper接口的代理实现类对象
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
            //调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配 映射文件中的SQL标签，并执行标签中的SQL语句
        int result = userMapper.insertUser();
        //sqlSession.commit();
        System.out.println("结果："+result);
        sqlSession.close();//关闭会话

    }
````

执行SQL语句的另一种形式（用得不多）：

````java
UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
int result = userMapper.insertUser();
替换为：
int result = sqlSession.insert("com.mapper.UserMapper.insertUser");
````



## 加入log4j日志功能

* 加入依赖

````xml
<!-- log4j日志 -->
    <dependency> 
        <groupId>log4j</groupId> 
        <artifactId>log4j</artifactId> 
        <version>1.2.17</version> 
</dependency>
````

* 加入log4j的配置文件

  * log4j的配置文件名为log4j.xml，存放的位置是src/main/resources目录下

  * 日志的级别:FATAL(致命)>ERROR(错误)>WARN(警告)>INFO(信息)>DEBUG(调试)

    从左到右打印的内容越来越详细

````xml
<?xml version="1.0" encoding="UTF-8" ?> 
<!DOCTYPE log4j:configuration SYSTEM "log4j.dtd"> 
<log4j:configuration xmlns:log4j="http://jakarta.apache.org/log4j/"> 
    <appender name="STDOUT" class="org.apache.log4j.ConsoleAppender"> 
        <param name="Encoding" value="UTF-8" /> 
        <layout class="org.apache.log4j.PatternLayout">
            <param name="ConversionPattern" value="%-5p %d{MM-dd HH:mm:ss,SSS} %m (%F:%L) \n" /> 
        </layout> 
    </appender> 
    <logger name="java.sql"> 
        <level value="debug" /> 
    </logger> 
    <logger name="org.apache.ibatis">
        <level value="info" /> 
    </logger> <root><level value="debug" /> 
    <appender-ref ref="STDOUT" /> 
    </root> 
</log4j:configuration>
````





# 三、MyBatis核心配置文件

>配置文件了解即可，以后整合Spring很多不需要配置，交给Spring来管理

核心配置文件的configuration标签中的内容各个标签必须按照固定的顺序：

````xml
<configuration>
  properties
  settings
  typeAliases
  typeHandlers
  objectFactory
  objectWrapperFactory
  reflectorFactory
  plugins
  environments
  databaseIdProvider
  mappers
</configuration>
````

## properties

* 引入properties文件此后可以在当前文件中使用${key}的方式访问value

````xml
<properties resource="jdbc.properties"/>
````

## settings

* settings是复数标签，内部可以有多个子标签setting

* 每一个setting都是键值对，有name和value属性，name代表键，value表示值

* 常用setting一览

  | name                     | 含义                                                         | value      | value默认值 |
  | ------------------------ | ------------------------------------------------------------ | ---------- | ----------- |
  | lazyLoadingEnabled       | 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载       | true/false | false       |
  | aggressiveLazyLoading    | 设置为false为按需加载（能够实现延迟加载），设置为true为完整加载，任何方法的调用都会加载该对象的所有属性。（完整加载：不论是否开启延迟加载，当执行分布查询，所有属性的查询sql都会执行） | true/false | false       |
  | mapUnderscoreToCamelCase | 将下划线映射为驼峰                                           | true/false | false       |

* 项目常用设置

  ````xml
     <settings>
          <setting name="mapUnderscoreToCamelCase" value="true"/>
          <setting name="lazyLoadingEnabled" value="true"/>
          <setting name="aggressiveLazyLoading" value="false"/>
      </settings>
  ````

  

## typeAliases

* 因为类的全类名路径往往较长，显得冗杂，可以为某个类型起别名，在Mybatis范围中可以使用别名来表示这个具体的类型
* Mybatis范围包括引入的各个文件，如Mapper.xml 映射文件（resultType属性）可以使用
* 别名不区分大小写
* typeAliases是复数标签，内部可以有多个单数标签typeAlias和package，前者是为具体某个类设置别名，后者是为某个包下的所有类起别名
* typeAlias：为具体某个类设置别名
  * 属性type 设置需要取别名的类
  * 属性alias 设置某个类型的别名，如果alias不写，默认的别名是该类名，且不区分大小写

````xml
    <typeAliases>
        <typeAlias type="com.pojo.User" alias="User"/>
    </typeAliases>
````

* package：以包为单位，将包下所有的类型取别名，实际中经常将包下所有的类型设置默认的类型别名，即类名
  * 属性name：设置需要取别名的包

````xml
  <typeAliases>
        <package name="com.pojo"/>
    </typeAliases>
````

## environments

* environments: 配置多个连接数据库的环境

  * 由于是复数标签，内部可以配多个单数标签environment
  * 属性default 设置默认使用的环境id

* environment 配置某个具体的环境。

  * 属性id是连接数据库的环境的唯一标识，不能重复

  * id="development"等于开发环境，id="test"等于测试环境
  * 每一个具体的environment内部有两个子标签：transactionManager和dataSource

* transactionManager：设置事务管理器

  * 属性type：设置事务管理方式，可选"JDBC/MANAGED" 
    * JDBC表示当前环境中，执行SQL时，使用的是JDBC中原生的事务管理方式，事务的提交或回滚需要手动设置
    * MANAGED：表示被管理，如被Spring管理

* dataSource：设置数据源
      * 属性type 数据源的类型 ,可选”POOLED/UNPOOLED/JNDI“ 
        

    * POOLED 表示使用数据库连接池缓存数据库连接
    * UNPOOLED 表示不使用数据库连接池
    * JNDI 表示使用上下文中的数据源 

     * 有4个子标签，设置连接的具体数据库，包括数据库驱动，数据库连接地址url，数据库用户名和密码，一般放在properties文件中，方便维护,此时用到标签properties来引入该文件,jdbc.properties文件如下：

    ````properties
  jdbc.driver=com.mysql.cj.jdbc.Driver
  jdbc.url=jdbc:mysql://localhost:3306/ssm? serverTimezone=UTC
  jdbc.username=root
  jdbc.password=root
    ````

````xml
    <environments default="development">
        <environment id="development">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.username}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
    </environments>
````



## Mappers

* 引入映射文件，执行Mapper接口中的方法时，Mybatis会在引入的映射文件中查找对应的SQL语句
* mappers是复数标签，内部可以有多个mapper和package，前者引入单个mapper文件，后者以包为单位，引入一个包下的mapper文件
* mapper：引入单个mapper文件
  * 属性resource设置引入的mapper文件位置

````xml
    <mappers>
        <mapper resource="mappers/UserMapper.xml"/>
    </mappers>
````

* package：引入一个包下的映射文件，当映射文件较多时，可以以包为单位引入映射文件，此时要求：

  * mapper接口所在的包要和映射文件所在的包一致

    > 映射文件要求放在resource目录下，此目录不能创建包，只能通过创建多层目录来模拟包,创建多层目录以斜线/划分，创建多层包以.划分
    >
    > resource目录和java目录只是为了把配置文件和主程序的类分开而设置的两个目录，但其实两个目录的内容会加载到同一个路径下：类路径下。

  * mapper接口要和映射文件的名字一致

````xml
 <!--引入映射文件-->
    <mappers>
        <package name="包名"/>
    </mappers>
````

# 四、MyBatis的简单的增删改查

````java
  增：
   <!--int insertUser(User user);-->
    <insert id="insertUser">
insert into t_user values(null,#{username},#{password},#{age},#{gender},#{email})
    </insert>

  删：
    <!--  int deleteUser();-->
    <delete id="deleteUser">
        delete from t_user where id=1
    </delete>
  
  改：    
    <!--int updateUser();-->
    <update id="updateUser">
        update t_user set username='zmt',password='123' where id=2
    </update>

  查：
    <!--   List<User> getAllUser();-->
    <select id="getAllUser" resultType="User">
        select * from t_user
    </select>
````



# 五、 MyBatis获取参数值的两种方式

* Java开发的项目主要是B/S系统，即浏览器/服务器,该系统的工作模式是通过浏览器页面、视图收集用户输入的一些数据，提交到服务器中，在服务器中获取后传输到Service处理业务逻辑，再传输到DAO，在DAO的实现类中我们需要将这些数据拼接到SQL语句中，然后执行SQL语句，最终可把用户相关的数据保存到数据库中

  >在JDBC将数据拼接SQL语句中，有两种方式：字符串拼接和占位符。字符串拼接需要手动设置单引号，占位符方式需要在SQL语句中需要赋值的地方写上？号，在通过预编译对象的set方法为占位符赋值

* MyBatis获取参数值：即如何在映射文件中获取对应的mapper接口方法的参数，来拼接参数值

  >Mybatis使用面向接口编程，创建Mapper接口且没有实现类，映射文件中的SQL语句直接对应接口方法，当调用Mapper中的有参方法时，需要在SQL语句中通过特定的方式获取方法的参数，然后拼接到SQL语句

* MyBatis获取参数值的两种方式：**${}**和**#{}**

  * ${}的本质就是字符串拼接，#{}的本质就是占位符赋值
  * ${}使用字符串拼接的方式拼接sql，**若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；**
  * #{}使用占位符赋值的方式拼接sql，**此时为字符串类型或日期类型的字段进行赋值时，会自动添加单引号**

* 当Mapper接口的参数个数、类型不一样时，获取参数值的方式也是不一样

### 单个字面量类型的参数

>字面量：如数字1或者字符串‘hello’等数据
>
>字面量类型：字符串、基本数据类型以及包装类

* 若mapper接口中的方法参数为单个的字面量类型，此时可以使用${}和#{}以任意的名称获取参数的值，注意${}需要手动加单引号

* 此时#{}和${}里的字符串名不重要，重要的是参数的位置，写成#{abc}也正确,最好按参数名来赋值，实现键名实意

  >在Mybatis执行SQL语句的底层代码，不知道该方法的参数名，只能获取到传递过来的参数值，所以SQL语句{}中 的名字不重要，与参数的位置有关

````xml
<!--User getUserByName(String name);-->

<!--${}方式-->
<select id="getUserByName" resultType="User">
        select * from admin where username = '${name}'
    </select>

<!--#{}方式-->
<select id="getUserByName" resultType="User">
        select * from admin where username = #{name}
    </select>
````



### **多个字面量类型的参数**

* 若mapper接口中的方法参数为多个时：此时MyBatis会**自动将这些参数放在一个map集合中**，可以以arg0,arg1...为键，以参数为值；也可以以param1,param2...为键，以参数为值；因此只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号

* arg和param可以混用，但最好不要

````xml
<!--User checkLogin(String name,String password);--> 

<select id="checkLogin" resultType="User">
        select * from t_user where username = #{param1} and password=#{param2}
    </select>

  <select id="checkLogin" resultType="User">
        select * from t_user where username = #{arg0} and password=#{param2}
    </select>

 <select id="checkLogin" resultType="User">
       select * from t_user where username='${arg0}' and password='${arg1}'
    </select>
````

### **map**集合类型的参数

* 若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中，然后设置方法参数为Map集合，这样只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号

````xml
<!-- User checkLogin(Map<String,Object> map);-->
<select id="checkLogin" resultType="User">
        select * from t_user where username = #{username} and password=#{password}
    </select>
````

此时sql语句寻找的是键为username和password的值，那么传入的map集合应该为该键赋值,不赋值的话值为null

````java
 HashMap<String, Object> map = new HashMap<>();
        map.put("username","123");
        map.put("password","123");
 User result = userMapper.checkLogin(map);
````

### **实体类类型的参数**（建议使用）

>map集合属于键值对的结构，其实实体类对象属性名和属性值也是键值对结构

* 若mapper接口中的方法参数为实体类对象时，此时可以使用${}和#{}，通过访问实体类对象中的属性名获取属性值，注意${}需要手动加单引号

  >可以理解为：当mapper接口中的方法参数为实体类对象，此时MyBatis会**自动将这些参数放在一个map集合中**，以对象中的属性名为键，以属性值为值；

  > 属性名的获取：只和get和set方法有关
  >
  > 属性并不等同于成员变量，在实体类中存在成员变量，根据这些成员变量创建了get和set方法，获取属性名就是通过将get方法和set方法的方法名去掉get或set然后将剩下的字符串首字母小写，即可得到属性名。
  >
  > 获取属性找get方法，设置属性找set方法。
  >
  > 存在没有成员变量但有get和set方法，这种情况下还能获取和设置属性。

```xml
   <!--int insertUser(User user);-->
    <insert id="insertUser">
insert into t_user values(null,#{username},#{password},#{age},#{gender},#{email})
    </insert>
```

### 使用@Param标识参数（建议使用）

* 可以通过@Param注解标识mapper接口中的方法参数，此时，会将这些参数放在map集合中，以@Param注解的value属性值为键，以参数为值；也可以以param1,param2...为键，以参数为值；只需要通过${}和#{}访问map集合的键就可以获取相对应的值，注意${}需要手动加单引号

* 该种方式其实是获取多个字面量类型和获取map集合类型的两种方法的混合
* @Param("username")是@Param(value="username")的简写

````xml
  <!-- User checkLogin(@Param("username") String username, @Param("password") String password);-->
    <select id="checkLogin" resultType="User">
        select * from t_user where username='${username}' and password='${password}'
    </select>

   <select id="checkLogin" resultType="User">
        select * from t_user where username='${param1}' and password='${param2}'
    </select>
````





# 六、**MyBatis**的各种查询功能

使用查询语句时，查询出来的数据可能有一条、也可能有多条，甚至可以查询出单行单列的数据，此时针对不同情况有不同处理方式。

### **查询一个实体类对象**

* 若SQL语句查询的结果有多条时，一定不能以实体类类型作为方法的返回值，否则会出异常TooManyResultsException：Expected one result (or null) to be returned by selectOne(), but found: XXX(大于1)

````xml
<!--User getUserById(@Param("id") int id);--> <select id="getUserById" resultType="User"> 
    select * from t_user where id = #{id} 
</select>
````

### **查询一个list**集合

查询数据有一条或者多条，可以通过该方式实现

````xml
  <!--   List<User> getAllUser();-->
    <select id="getAllUser" resultType="User">
        select * from t_user
    </select>
````

### **查询单行单列数据**

* 单行单列的数据一般为基本数据类型，此时resultType需要添加该数据所属类型，由于MyBatis为Java中常用类型设置了别名，此时可以不写全类名而写别名

* 几个常用的类型别名：

  * java.lang.Interger类：Interger，int
  * int：`__int`，`_interger`
  * Map类:map
  * String类:string

  >所有的类型别名可在mybatis的官方文档（mybatis包中）找到



````xml
<!--int getCount();--> 
<select id="getCount" resultType="_integer"> select count(1) from t_user </select>
````



### **查询一条数据为**map集合

* 有时候查询出来的结果与任何实体类都不匹配，那么我们将数据封装为map集合，此时Map集合以表中的字段名为键，字段值为值 
* 如果某个字符值为null，那么该字段对应的键值对在map集合中不会保存
* 若查询的结果有多条时，一定不能map类型作为方法的返回值，否则会出异常TooManyResultsException：Expected one result (or null) to be returned by selectOne(), but found: XXX(大于1)

````xml
<!--Map<String, Object> getUserToMap(@Param("id") int id);--> 
<select id="getUserToMap" resultType="map"> 
    select * from t_user where id = #{id} 
</select> 
<!--结果： {password=123, gender=女, id=2, age=23, email=12345@qq.com, username=zmt}-->
````

### **查询多条数据为**map**集合**

* 方法一：将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此 时可以将这些map放在一个list集合中获取 ,这个方法用得更多

````xml
 <!--List<Map<String, Object>> getAllUserToMap();-->
    <select id="getAllUserToMap" resultType="map">
        select * from t_user
    </select>
<!--[
{password=123, gender=女, id=2, age=23, username=zmt},
 {password=123456, gender=男, id=3, age=23, email=12345@qq.com, username=admin}, {password=111, gender=男, id=5, age=12, email=143@163.com, username=lihua}
]
-->
````

* 方法二：将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据，此时需要通过@MapKey注解设置map集合的键，值是每条数据所对应的map集合

````xml
<!--@MapKey("id") Map<String, Object> getAllUserToMap();--> 
<select id="getAllUserToMap" resultType="map"> 
    select * from t_user 
</select> 
结果： <!-- {2={password=123, gender=女, id=2, age=23, username=zmt}, 3={password=123456, gender=男, id=3, age=23, email=12345@qq.com, username=admin}, 5={password=111, gender=男, id=5, age=12, email=143@163.com, username=lihua}}
-->
````



# 七、 **特殊**SQL**的执行**

### **模糊查询**

* 方式1：``like '%${res}%``
  * 对于'%?%'，此时？被当作是字符串中的一部分，不会被解析为占位符，因此不能使用`like '%#{str}%'`方式
* 方式2：使用字符串拼接函数  `like concat('%',#{res},'%')`
* 方式3：`like "%"#{mohu}"%"`,该方式用得最多

````xml
<!--List<User> testMohu(@Param("mohu") String mohu);--> 
<select id="testMohu" resultType="User">
    <!--方式1：select * from t_user where username like '%${mohu}%'--> 
    <!--方式2：select * from t_user where username like concat('%',#{mohu},'%')--> 
    select * from t_user where username like "%"#{mohu}"%"
</select>
````

### **批量删除**

* 批量删除：通过一条SQL语句删除多条数据，主要针对如下的SQL语句的字符串拼接

  ````sql
  delete from t_user where id in(7,8);
  ````

* 只能使用${}方式，因为#{}方式会自动添加单引号，而in()内的数字不能添加单引号

  * 但参数值拼接在SQL语句中所有不能添加单引号的地方，都只能使用${}

````xml
    <!--int deleteMore(@Param("ids") String ids);-->
    <delete id="deleteMore">
 delete from t_user where id in (${ids})
    </delete>
````



### 动态设置表名

* 因为SQL语句中的表名也不能添加单引号，故只能使用${}

````xml
<!--List<User> getAllUser(@Param("tableName") String tableName);--> 
<select id="getAllUser" resultType="User"> 
    select * from ${tableName}
</select>
````



### **添加功能获取自增的主键**

>是JDBC的功能

* 有的表中主键是自增的，当我们在该表中新增一条记录时，主键的值会被自动赋值，当想要获取这个新增记录的自增主键的值时，即为添加功能获取自增的主键

  >场景模拟：
  >
  >t_clazz(clazz_id,clazz_name)
  >
  >t_student(student_id,student_name,clazz_id)
  >
  >1、添加班级信息
  >
  >2、获取新添加的班级的id
  >
  >3、为班级分配学生，即将某学的班级id修改为新添加的班级的id

* 因为增加语句insert的返回值是受影响的行数，因此只能将获取的自增的主键放在传输的参数对象的某个属性中 

  * useGeneratedKeys：表示当前添加功能使用自增的主键
  * keyProperty：把添加的数据的自增主键存储到传输过来的实体类对象的某个属性中

````xml
<!--int insertUser(User user);--> 
<insert id="insertUser" useGeneratedKeys="true" keyProperty="id"> 
     insert into t_user values(null,#{username},#{password},#{age},#{gender},#{email})
</insert>
````



# 八、**自定义映射**resultMap

* resultMap标签：设置自定义映射

  * 属性： id：自定义映射的唯一标识 ，SQL语句中的resultMap填的就是自定义的resultMap的id
  * type：查询的数据要映射的实体类的类型 
* resultMap内部子标签有id、result、collection、association、property、column，其中常用为前四个

  * id：设置主键和属性的映射关系 
  * result：设置普通字段和属性的映射关系
  * association：设置多对一的映射关系 (处理实体类类型的属性)
  * collection：设置一对多的映射关系 属性： 
  * property：设置映射关系中实体类中的属性名 
  * column：设置映射关系中表中的字段名
* id和resultt内部子标签用到的属性：

  * property 实体类的属性名
  * colunmn 对应表的字段
* 在association有两个属性要填写，内部也如resultMap一样有id、result子标签，用来设置实体类类型的属性的映射
  * property 实体类的属性名，该属性为实体类类型
  * javaType 属性的类型
* 在分布查询中，association有三个属性需要填写
  * property 实体类的属性名，该属性为实体类类型
  * select 设置下一步查询的sql的唯一标识
  * column  将查询出的某个字段作为下一步分布查询的sql的条件

### 字段名和实体类中的属性名不一致

* 若字段名和实体类中的属性名不一致，可以在SQL语句中为查询的字段设置别名，和属性名保持一致

  ````xml
  <!-- Emp selectEmpById(@Param("id") Integer id);-->
      <select id="selectEmpById" resultType="emp">
          select emp_id empId,emp_name empName,age,gender from t_emp where emp_id=#{id}
      </select>
  ````

* 当字段名符合Mysql数据库的规则（使用下划线`__`），实体类中的属性名符合Java的规则（使用驼峰），此时可以在MyBatis的核心配置文件中设置一个全局配置信息mapUnderscoreToCamelCase，可以在查询表中数据时，自动将下划线_类型的字段名转换为驼峰，如emp_id:empId

  ````xml
  <settings>
      <setting name="mapUnderscoreToCamelCase" value="true"/>
      </settings>
  ````

* 最后只要 字段名和实体类中的属性名不一致，都可以使用resultMap：设置自定义映射，处理处理字段和属性的映射关系

  ````xml
   <resultMap id="empMap" type="Emp">
          <id column="emp_id" property="empId"/>
          <result column="emp_name" property="empName"/>
          <result column="gender" property="gender"/>
          <result column="age" property="age"/>
      </resultMap>
      <select id="selectEmpById" resultMap="empMap">
          select * from t_emp where emp_id=#{id}
      </select>
  ````

  

### 多对一映射处理

>对一保持的是一个对象，对多保持的是一个集合

````java
场景模拟：
查询员工信息以及员工所对应的部门信息
因为员工表和部门表是多对一关系，可以在员工表设置一个部门对象dept来保存员工的部门信息
public class Emp {
    ...
    private Dept dept;
}
这种情况有三种处理方式
````

#### 方式一：级联方式处理

````sql
    <!-- Emp selectEmpAndDeptById(@Param("id") Integer id);-->
    <resultMap id="empAndDeptMap" type="Emp">
        <id column="emp_id" property="empId"/>
        <result column="emp_name" property="empName"/>
        <result column="gender" property="gender"/>
        <result column="age" property="age"/>
        <result column="dept_id" property="dept.deptId"/>
        <result column="dept_name" property="dept.deptName"/>
    </resultMap>

    <select id="selectEmpAndDeptById" resultMap="empAndDeptMap">
        select *
        from t_emp emp
        left join t_dept dept
        on emp.dept_id = dept.dept_id
        where emp_id=#{id}
    </select>


````

#### 方式二：association

````sql
   <resultMap id="empAndDeptMap" type="Emp">
        <id column="emp_id" property="empId"/>
        <result column="emp_name" property="empName"/>
        <result column="gender" property="gender"/>
        <result column="age" property="age"/>
        <association property="dept" javaType="Dept">
            <id column="dept_id" property="deptId"/>
            <result column="dept_name" property="deptName"/>
        </association>
    </resultMap>

````





#### 方式三：分布查询->延迟加载

* 需要思考:查询需要分为几步，每一步需要干什么

* 分步查询的优点：可以实现延迟加载

  >分布查询中通过两个sql语句把员工信息和对应的部门信息查询了出来，开启延迟加载后， 如果只需要获取员工信息而不获取部门信息，就只执行获取员工的sql，而不会执行获取部门的sql

* 要实现延迟加载必须在核心配置文件中设置全局配置信息：

  * lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象都会延迟加载

  * aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载

  此时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql。

* 因为配置文件的配置是全局配置，对所有分布查询都有效，当某个分布查询不想使用延迟加载时，可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载， fetchType="lazy(延迟加载)|eager(立即加载)"

  ````sql
   <association property="dept"
                       fetchType="lazy"
                       select="com.mapper.DeptMapper.selectEmpAndDeptStepTwo"
                       column="dept_id">
          </association>
  ````

  

  

  

  

  

  

  

````sql
第一步：先根据id在员工表查找员工

    <!-- Emp selectEmpAndDeptStepOne(@Param("id") Integer id);-->
    <resultMap id="empAndDeptStepOneMap" type="Emp">
        <id column="emp_id" property="empId"/>
        <result column="emp_name" property="empName"/>
        <result column="gender" property="gender"/>
        <result column="age" property="age"/>
        <association property="dept"
                     select="com.mapper.DeptMapper.selectEmpAndDeptStepTwo"
                     column="dept_id">
        </association>
    </resultMap>
    <select id="selectEmpAndDeptStepOne" resultMap="empAndDeptStepOneMap">
        select * from t_emp where emp_id=#{id}
    </select>

第二步：根据员工的dept_id去部门表查找部门信息

 <!-- Dept selectEmpAndDeptStepTwo(@Param("deptId") Integer id);-->
    <select id="selectEmpAndDeptStepTwo" resultType="Dept">
        select * from t_dept where dept_id=#{deptId}
    </select>
    
测试：
开启延迟加载后
Emp emp = mapper.selectEmpAndDeptStepOne(1);
System.out.println(emp.getEmpName());
只会执行查询员工表的sql语句：
DEBUG 08-06 22:53:39,560 ==>  Preparing: select * from t_emp where emp_id=? (BaseJdbcLogger.java:137) 
DEBUG 08-06 22:53:39,602 ==> Parameters: 1(Integer) (BaseJdbcLogger.java:137) 
DEBUG 08-06 22:53:39,683 <==      Total: 1 (BaseJdbcLogger.java:137) 
zmt

对于如下测试
Emp emp = mapper.selectEmpAndDeptStepOne(1);
System.out.println(emp);  
会执行查询员工和部门的两条sql语句：
DEBUG 08-06 22:55:55,285 ==>  Preparing: select * from t_emp where emp_id=? (BaseJdbcLogger.java:137) 
DEBUG 08-06 22:55:55,324 ==> Parameters: 1(Integer) (BaseJdbcLogger.java:137) 
DEBUG 08-06 22:55:55,394 <==      Total: 1 (BaseJdbcLogger.java:137) 
DEBUG 08-06 22:55:55,395 ==>  Preparing: select * from t_dept where dept_id=? (BaseJdbcLogger.java:137) 
DEBUG 08-06 22:55:55,396 ==> Parameters: 1(Integer) (BaseJdbcLogger.java:137) 
DEBUG 08-06 22:55:55,401 <==      Total: 1 (BaseJdbcLogger.java:137) 
Emp{empId=1, empName='zmt', age=12, gender='男', dept=Dept{deptId=1, deptName='A'}}
````



### 一对多映射处理

#### 方式一：collection

#### 方式二：分步查询

# 九、动态SQL



# 十、MyBatis的逆向工程（MBG）

* 正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的。

* 逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源：

​      Java实体类

​     Mapper接口

​     Mapper映射文件



## 创建逆向工程的步骤

1. **添加依赖和插件**

   ````xml
   <!-- 依赖 MyBatis 核心包 -->
       <dependencies>
           <dependency>
               <groupId>org.mybatis</groupId>
               <artifactId>mybatis</artifactId>
               <version>3.2.8</version>
           </dependency>
       </dependencies>
   
       <!-- 控制 Maven 在构建过程中相关配置 -->
       <build>
       <!-- 构建过程中用到的插件 -->
          <plugins>
       <!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 -->
           <plugin>
              <groupId>org.mybatis.generator</groupId>
              <artifactId>mybatis-generator-maven-plugin</artifactId>
              <version>1.3.0</version>
   
       <!-- 插件的依赖 -->
           <dependencies>
       <!-- 逆向工程的核心依赖 -->
          <dependency>
            <groupId>org.mybatis.generator</groupId>
            <artifactId>mybatis-generator-core</artifactId>
            <version>1.3.2</version>
         </dependency>
       <!-- 数据库连接池 -->
         <dependency>
           <groupId>com.mchange</groupId>
           <artifactId>c3p0</artifactId>
           <version>0.9.2</version>
         </dependency>
           <!-- MySQL 驱动 -->
           <dependency>
               <groupId>mysql</groupId>
               <artifactId>mysql-connector-java</artifactId>
               <version>5.1.8</version>
           </dependency>
       </dependencies>
       </plugin>
       </plugins>
       </build>
   ````

   

2. **创建MyBatis的核心配置文件**

3. **创建逆向工程的配置文件**

   文件名必须是：generatorConfig.xml

   ````xml
   <!DOCTYPE generatorConfiguration
           PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
           "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
   
   <generatorConfiguration>
       <!-- mybatis-generator:generate -->
       <!--targetRuntime:执行生成的逆向工程的脚本
             MyBatis3Simple:生成基本的CRUD
             MyBatis3：生成待条件的CRUD
             -->
       <context id="atguiguTables" targetRuntime="MyBatis3">
           <commentGenerator>
               <!-- 是否去除自动生成的注释 true:是;false:否 -->
               <property name="suppressAllComments" value="true" />
           </commentGenerator>
           <!--数据库连接的信息：驱动类、连接地址、用户名、密码 -->
           <jdbcConnection driverClass="com.mysql.jdbc.Driver"
                           connectionURL="jdbc:mysql://localhost:3306/project_crowdfunding"
                           userId="root"
                           password="root">
           </jdbcConnection>
           <!-- 默认 false，把 JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，
           为 true 时把 JDBC DECIMAL和 NUMERIC 类型解析为 java.math.BigDecimal -->
           <javaTypeResolver>
               <property name="forceBigDecimals" value="false" />
           </javaTypeResolver>
   
           <!-- targetProject:生成 Entity 类的路径 -->
           <javaModelGenerator targetProject=".\src\main\java" targetPackage="com.entity">
               <!-- enableSubPackages:是否让 schema 作为包的后缀 -->
               <property name="enableSubPackages" value="false" />
               <!-- 从数据库返回的值被清理前后的空格 -->
               <property name="trimStrings" value="true" />
           </javaModelGenerator>
   
           <!-- targetProject:XxxMapper.xml 映射文件生成的路径 -->
           <sqlMapGenerator targetProject=".\src\main\java\resources" targetPackage="com.mapper">
               <!-- enableSubPackages:是否让 schema 作为包的后缀 -->
               <property name="enableSubPackages" value="false" />
           </sqlMapGenerator>
   
           <!-- targetPackage：Mapper 接口生成的位置 -->
           <javaClientGenerator type="XMLMAPPER" targetProject=".\src\main\java" targetPackage="com.mapper">
               <!-- enableSubPackages:是否让 schema 作为包的后缀,即是否使用子包，若为true，路径上的每个.表示一层目录,为false时.无特殊含义 -->
               <property name="enableSubPackages" value="false" />
           </javaClientGenerator>
   
           <!-- 数据库表名字和我们的 entity 类对应的映射指定
             表明 ： 类名-->
           <table tableName="admin" domainObjectName="Admin" />
       </context>
   </generatorConfiguration>
   ````

   









